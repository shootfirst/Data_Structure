# graph

## 术语

加权图、有向图、无向图、顶点、边、路径、路径长度、环、负权环、连通性、度、入度、出度

## 表示方法

+ 邻接矩阵

+ 邻接表

## 最短路径算法

### dijkstra

dijkstra算法是计算单源最短路径非负权图算法

算法步骤：

+ 初始化dest和visit数组

+ 挑选出距离最短的顶点，记录其距离

+ 遍历所有顶点，看是否能够使用该最短顶点收缩

+ 重复这个步骤直到没有最短距离变化为止

[网络延迟时间](./code/网络延迟时间.java)

### floyd

floyd算法实际上是动态规划，比较是否经过点k

若最短路径经过点k，则D(i,j,k) = D(i,k,k − 1) + D(k,j,k − 1)
若最短路径不经过点k，则D(i,j,k) = D(i,j,k − 1)

算法步骤

+ 初始化pre和dest二维数组

+ 对于每个中转顶点顶点k

+ 对于每个起点u

+ 对于每个终点v

+ 判断是否能收缩

### bellman-ford

一步步迭代，求出最多经过0，1，2。。。n-1条边对最短路径

在一个有n个顶点的非负权环图中，两点间最短路径最多经过n个边

可以检测是否有负权环，即经过n-1次迭代后，第n次迭代距离还减少，则有负权环

实际上是动态规划

算法步骤

+ 初始化两个数组，pre和now

+ 迭代n-1次，对每个顶点v，找到终点是v的每个边，进行判断是否能进行收缩（这里直接遍历所有顶点也行）

优化：

我们在进行收缩的时候，不一定要使用前一次的结果来进行判断，可以直接使用现在的结果，也就是打破第k次循环最多经过k条边的最短路径的规则，这样将结果早点知道，如果相邻两次循环的结果一样，
那么我们可以直接退出

[K站中转内最便宜的航班](./code/K站中转内最便宜的航班.java)




## 最小生成树算法

生成树指的是无向图中，具有该图的全部顶点且边数最少的连通子图。

最小生成树指的是加权无向图中总权重最小的生成树。

[连接所有点的最小费用](./code/连接所有点的最小费用.java)

### kruscal

思路：

+ 将所有边加入优先队列

+ 依次取出最小的边，使用并查集判断两点是否在集合中，不在则加入

+ 循环直到凑齐所有顶点

### prime

思路：

+ 
