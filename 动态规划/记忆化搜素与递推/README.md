# 记忆化搜索

## 和动态规划关系

自顶向下和自底向上

记忆化搜索和动态规划从根本上来讲就是一个东西，任何一个 dp 方程都能转为记忆化搜索 ，反之亦然

核心思想均为：利用对于相同参数答案相同的特性，对于相同的参数（循环式的dp体现为数组下标），记录其答案，免去
重复计算，从而起到优化时间复杂度的作用

举例：

dp：dp[i][j][k]=dp[i+1][j+1][k−a[j]]+dp[i+1][j][k]

记忆化搜索：

```
int dfs( int i , int j , int k ){
    边界条件
    if( mem[i][j][k] != -1 ) return mem[i][j][k];
    return mem[i][j][k] = dfs(i+1,j+1,k-a[j]) + dfs(i+1,j,k);
}
int main(){
    memset(mem,-1,sizeof(mem));
    读入
    cout << dfs(1,0,0) << endl;
}
```

## 求解思路

方法I（由动态规划开始思考）:
+ 把这道题的dp状态和方程写出来
+ 根据他们写出dfs函数
+ 添加记忆化数组

方法II（由暴搜开始思考）:
+ 写出这道题的暴搜程序(最好是dfs)
+ 将这个dfs改成"无需外部变量"的dfs
+ 添加记忆化数组

## 题目

+ [大礼包](./code/大礼包.cpp)


