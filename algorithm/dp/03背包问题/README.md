# 背包问题

## 背包问题

背包问题可以分为01背包和完全背包（其他面试不考），题型也可以分为求最大值和求累加数

dp数组的存储可以分为二维数组和滚动数组


### 01背包

##### 原问题

问题复述：有n件物品和能装重量为w的背包，物品的重量为weight[i]，价值为value[i]。`每件物品只能装一次`，请问如何使装的物品价值最大？

+ 二维数组解法

dp数组定义：dp[i][j]表示可以使用物品0-i，重量为j的背包，价值最多是多少

状态转移：拿物品i:：dp[i][j] = dp[i - 1][j - weight[i]] + value[i]，不拿：dp[i][j] = dp[i - 1][j]。取较大值即可

初始化：dp[i][0] = 0 dp[0][j] = value[0](j >= weight[0]，因为背包必须要放下weight[0]，其余随便初始化，都会被覆盖)

遍历顺序：注意到状态转移方程，它会依赖左边和上面的值，先遍历背包，后遍历物品和先遍历物品，后遍历背包是都可以的。一般我们采取先遍历物品（更好理解）

+ 一维数组解法

dp数组定义：dp[j]表示重量为j的背包，价值最多是多少，迭代轮次为物品序号

状态转移：拿物品：dp[j] = dp[j - weight[i]] + value[i]，不拿：dp[j] = dp[j]。dp[j] = dp[j]就表示使用`上一维`的原值，dp[j] = dp[j - weight[i]]表示使用`上一维`下标为j -      weight[i]的值

初始化：都初始化为0即可。根据递推公式，需要保证初始值被覆盖才能得到正确结果，所以初始化为0

遍历顺序：只能先遍历物品，后遍历背包，而且遍历背包需要倒序遍历（参考上面状态转移的解释，正序遍历会导致同一间物品被放置多次）

注意，以上只是最原始的模板，具体题目的dp推导和dp初始化需要具体分析

##### 求最大值的01背包问题

[分割等和子集](./code/分割等和子集.java)

##### 求累加数的01背包问题

这是个求组合个数问题

[目标和](./code/目标和.java)



### 完全背包

##### 原问题

问题复述：有n件物品和能装重量为w的背包，物品的重量为weight[i]，价值为value[i]。`物品装填无次数限制`，请问如何使装的物品价值最大？

+ 二维数组解法

dp数组定义：dp[i][j]表示可以使用物品0-i，重量为j的背包，价值最多是多少

状态转移：拿物品i:：dp[i][j] = dp[i][j - weight[i]] + value[i]，不拿：dp[i][j] = dp[i - 1][j]。取较大值即可

初始化：dp[i][0] = 0 ,具体问题分析，一般是dp[0][j] = j / weight[0] * value[0]

遍历顺序：注意到状态转移方程，它会依赖左边和上面的值，先遍历背包，后遍历物品和先遍历物品，后遍历背包是都可以的。一般我们采取先遍历物品（更好理解）

+ 一维数组解法

dp数组定义：dp[j]表示重量为j的背包，价值最多是多少，迭代轮次为物品序号

状态转移：拿物品：dp[j] = dp[j - weight[i]] + value[i]，不拿：dp[j] = dp[j]。取较大值即可
    (dp[j] = dp[j]就表示使用`上一维`的原值，dp[j] = dp[j - weight[i]]表示使用`当前维度`下标为j - weight[i]的值)

初始化：都初始化为0即可。根据递推公式，需要保证初始值被覆盖才能得到正确结果，所以初始化为0

遍历顺序：无所谓(先遍历背包，后遍历物品意味着你会多次放同一个物品，满足多重背包定义，但是01背包定义不满足，所以01背包只能先物品，后背包)

注意，以上只是最原始的模板，具体题目的dp推导和dp初始化需要具体分析

##### 求最大值的完全背包问题

[零钱兑换](./code/零钱兑换.java)

[完全平方数](./code/完全平方数.java)

##### 求累加数的完全背包问题

求组合个数问题，遍历顺序必须是先物品后背包，一维二维都是如此！！！二维也注意复用之前值

[零钱兑换II](./code/零钱兑换II.java)

求排列个数问题，遍历顺序必须是先背包后物品，一维二维都是如此！！！二维也注意复用之前值

[组合总和IV](./code/组合总和IV.java)
