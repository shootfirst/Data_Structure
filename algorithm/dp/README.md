# dp

动态规划最重要的三个概念：

最优子结构

无后效性

重复子问题

https://blog.csdn.net/xiao_niu_1/article/details/12439565

动态规划解题步骤：

+ 状态定义(定义子问题)

+ 状态转移(状态转移方程的确定)

+ dp数组初始化

+ 顺序确立

+ 举例推导(用于肉眼debug)

记忆化搜索和递推是动态规划两种表现形式，一个自顶向下，一个自底向上

+ [大礼包](./大礼包.cpp)

让我们用这个"最长递增子序列(LIS)"问题作为例子，一步步演示如何判断它符合DP的三个特征。
判断过程演示
1. 检查"最优子结构"
思考过程：
大问题：求整个数组的最长递增子序列长度
子问题：求以某个位置i结尾的最长递增子序列长度
关键问题：大问题的最优解能否由子问题的最优解构成？
分析：
整个数组的最长递增子序列，必然是以某个位置i结尾的递增子序列
如果我们知道了以每个位置结尾的最长递增子序列长度，那么整个数组的LIS长度就是这些值中的最大值
以位置i结尾的LIS长度 = 1 + max{以位置j结尾的LIS长度}，其中j < i且nums[j] < nums[i]
结论：​ ✅ 具有最优子结构。大问题的最优解可以由子问题的最优解组合得到。
2. 检查"无后效性"
思考过程：
状态定义：dp[i]表示以第i个元素结尾的最长递增子序列长度
关键问题：未来决策是否只依赖当前状态，不依赖如何到达这个状态？
分析：
当我们计算dp[i]时，只需要知道前面所有dp[j] (j < i)的值
我们不关心这些dp[j]是如何计算出来的，也不关心具体的子序列是什么
只要知道"以位置j结尾的LIS长度"这个数值就足够了
未来计算dp[k] (k > i)时，也只需要dp[i]这个数值，不关心我们是如何得到它的
举例验证：
对于nums = [10,9,2,5,3,7,101,18]
计算dp[3]（以5结尾）：我们只需要知道dp[2]（以2结尾）=1，就能算出dp[3] = 2
我们不需要知道以2结尾的具体子序列是[2]还是别的什么
结论：​ ✅ 满足无后效性。
3. 检查"重复子问题"
思考过程：
关键问题：在暴力递归求解时，是否会重复计算相同的子问题？
分析：
暴力解法：对于每个元素，选择"包含"或"不包含"，时间复杂度O(2^n)
在递归树中，以不同位置结尾的LIS会被多次计算
例如，计算以位置i结尾的LIS时，需要计算所有j < i且nums[j] < nums[i]的dp[j]
这些dp[j]在计算其他位置的LIS时会被重复用到



















